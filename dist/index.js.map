{"version":3,"sources":["../src/valis-client.ts"],"names":["DEFAULTS","nowMs","ValisClient","EventEmitter","url","opts","event","fn","s","level","msg","meta","resolve","reject","ws","cleanup","onOpen","onMessage","onClose","onError","ev","data","front","it","err","e","connectTimeout","code","reason","command","payload","timeoutId","interval","t0","rtt","base","jitter","delay"],"mappings":"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","file":"index.js","sourcesContent":["import EventEmitter from 'eventemitter3';\n\nexport type ValisClientStatus =\n  | 'idle'\n  | 'connecting'\n  | 'open'\n  | 'reconnecting'\n  | 'closing'\n  | 'closed';\n\nexport type NetworkResponse = {\n  stable: string;\n  genesis: number;\n  utime: number;\n  hour: number;\n  seconds: number;\n  tockdatahash: string;\n  rollups: number;\n  numtx: number;\n  failed: number;\n  changes: number;\n  utc: number;\n  chainlag: number;\n  result: 'success' | string;\n};\n\nexport type TokensResponse = {\n  assets: string[];\n  utc: number;\n  chainlag: number;\n  result: 'success' | string;\n};\n\nexport type ValisClientOptions = {\n  /** Auto reconnect on drop */\n  reconnect?: boolean;\n  /** Initial reconnect delay (ms) */\n  reconnectInitialDelayMs?: number;\n  /** Max reconnect delay (ms) */\n  reconnectMaxDelayMs?: number;\n  /** Jitter factor (0..1) */\n  reconnectJitter?: number;\n  /** Per-command timeout (ms) */\n  requestTimeoutMs?: number;\n  /** Heartbeat using \"network\" command (ms). Set 0/null to disable. */\n  heartbeatIntervalMs?: number;\n  /** Optional structured logger */\n  onLog?: (\n    level: 'debug' | 'info' | 'warn' | 'error',\n    msg: string,\n    meta?: unknown,\n  ) => void;\n};\n\nexport type Events = {\n  open: Event;\n  close: CloseEvent;\n  error: Error;\n  message: unknown;\n  reconnecting: { attempt: number; delayMs: number };\n  heartbeat: { ok: boolean; rttMs?: number };\n};\n\nconst DEFAULTS = {\n  reconnect: true,\n  reconnectInitialDelayMs: 500,\n  reconnectMaxDelayMs: 12_000,\n  reconnectJitter: 0.2,\n  requestTimeoutMs: 8_000,\n  heartbeatIntervalMs: 15_000,\n} satisfies Required<\n  Pick<\n    ValisClientOptions,\n    | 'reconnect'\n    | 'reconnectInitialDelayMs'\n    | 'reconnectMaxDelayMs'\n    | 'reconnectJitter'\n    | 'requestTimeoutMs'\n    | 'heartbeatIntervalMs'\n  >\n>;\n\nfunction nowMs(): number {\n  return typeof performance !== 'undefined' && performance.now\n    ? performance.now()\n    : Date.now();\n}\n\n// Generic queue item; we store them as any internally\ntype QueueItem<T = unknown> = {\n  payload: string;\n  resolve: (v: T) => void;\n  reject: (e: unknown) => void;\n  timeoutId: any; // node/browser timers differ; keep it loose\n};\n\nexport class ValisClient {\n  private url: string;\n  private opts: ValisClientOptions;\n  private ws: WebSocket | null = null;\n  private ee = new EventEmitter<Events>();\n  private status: ValisClientStatus = 'idle';\n  private reconnectAttempt = 0;\n  private connectPromise: Promise<void> | null = null;\n  private heartbeatTimer: any = null; // node/browser compatibility\n  private awaitingResponse = false;\n  private manualClose = false;\n  private queue: Array<QueueItem<any>> = [];\n\n  constructor(url: string, opts: ValisClientOptions = {}) {\n    this.url = url;\n    this.opts = { ...DEFAULTS, ...opts };\n  }\n\n  getStatus(): ValisClientStatus {\n    return this.status;\n  }\n\n  on<K extends keyof Events>(\n    event: K,\n    fn: (payload: Events[K]) => void,\n  ): () => void {\n    this.ee.on(event, fn as any);\n    return () => this.ee.off(event, fn as any);\n  }\n\n  private setStatus(s: ValisClientStatus) {\n    this.status = s;\n  }\n\n  private log(\n    level: 'debug' | 'info' | 'warn' | 'error',\n    msg: string,\n    meta?: unknown,\n  ) {\n    this.opts.onLog?.(level, msg, meta);\n  }\n\n  async connect(): Promise<void> {\n    if (typeof WebSocket === 'undefined') {\n      throw new Error(\n        'WebSocket API not available. valis-client is browser-only.',\n      );\n    }\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) return;\n    if (this.connectPromise) return this.connectPromise;\n\n    this.manualClose = false;\n    this.setStatus('connecting');\n\n    this.connectPromise = new Promise<void>((resolve, reject) => {\n      const ws = new WebSocket(this.url);\n      this.ws = ws;\n\n      const cleanup = () => {\n        ws.removeEventListener('open', onOpen);\n        ws.removeEventListener('message', onMessage);\n        ws.removeEventListener('close', onClose);\n        ws.removeEventListener('error', onError);\n      };\n\n      const onOpen = () => {\n        this.setStatus('open');\n        this.reconnectAttempt = 0;\n        this.ee.emit('open', new Event('open'));\n        this.log('info', 'WebSocket open');\n        this.flushQueue();\n        this.startHeartbeat();\n\n        this.connectPromise = null;\n        // keep listeners for lifetime; we've already added them below\n        resolve();\n      };\n\n      const onMessage = (ev: MessageEvent) => {\n        let data: unknown = ev.data;\n        if (typeof data === 'string') {\n          try {\n            data = JSON.parse(data);\n          } catch {\n            /* keep string */\n          }\n        }\n\n        // SERIAL: resolve next waiter\n        this.awaitingResponse = false;\n        const front = this.queue.shift();\n        if (front) {\n          globalThis.clearTimeout(front.timeoutId);\n          front.resolve(data);\n        } else {\n          this.ee.emit('message', data);\n        }\n        this.flushQueue();\n      };\n\n      const onClose = (ev: CloseEvent) => {\n        this.setStatus('closed');\n        this.log('warn', 'WebSocket closed', {\n          code: ev.code,\n          reason: ev.reason,\n        });\n        this.stopHeartbeat();\n        this.ee.emit('close', ev);\n\n        // Reject pending\n        while (this.queue.length) {\n          const it = this.queue.shift()!;\n          globalThis.clearTimeout(it.timeoutId);\n          it.reject(new Error('Connection closed'));\n        }\n\n        cleanup();\n        this.ws = null;\n        this.connectPromise = null;\n\n        if (!this.manualClose && this.opts.reconnect) {\n          this.scheduleReconnect();\n        }\n      };\n\n      const onError = (err: Event | Error) => {\n        const e = err instanceof Error ? err : new Error('WebSocket error');\n        this.ee.emit('error', e);\n        this.log('error', 'WebSocket error', e);\n      };\n\n      ws.addEventListener('open', onOpen);\n      ws.addEventListener('message', onMessage);\n      ws.addEventListener('close', onClose);\n      ws.addEventListener('error', onError);\n\n      // Guard connect wait with a timeout\n      const connectTimeout = globalThis.setTimeout(() => {\n        if (this.status !== 'open') {\n          try {\n            ws.close(4000, 'connect-timeout');\n          } catch {}\n          this.connectPromise = null;\n          reject(\n            new Error(`Connect timeout after ${this.opts.requestTimeoutMs} ms`),\n          );\n        }\n      }, this.opts.requestTimeoutMs);\n\n      ws.addEventListener(\n        'open',\n        () => {\n          globalThis.clearTimeout(connectTimeout as any);\n        },\n        { once: true },\n      );\n    });\n\n    return this.connectPromise;\n  }\n\n  async disconnect(code?: number, reason?: string): Promise<void> {\n    this.manualClose = true;\n    this.setStatus('closing');\n    this.stopHeartbeat();\n    try {\n      this.ws?.close(code, reason);\n    } catch {}\n    this.ws = null;\n    this.setStatus('closed');\n    this.connectPromise = null;\n  }\n\n  // Overloads: keep a typed path if you add a CommandMap later\n  async sendCommand<T = unknown>(command: string | object): Promise<T> {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      await this.connect();\n    }\n    const payload =\n      typeof command === 'string' ? command : JSON.stringify(command);\n\n    return new Promise<T>((resolve, reject) => {\n      const timeoutId = globalThis.setTimeout(() => {\n        if (this.queue[0]?.payload === payload) {\n          this.queue.shift();\n          this.awaitingResponse = false;\n        }\n        reject(\n          new Error(`Request timed out after ${this.opts.requestTimeoutMs} ms`),\n        );\n        this.maybeReconnectOnTimeout();\n      }, this.opts.requestTimeoutMs) as any;\n\n      this.queue.push({\n        payload,\n        resolve,\n        reject,\n        timeoutId,\n      } as QueueItem<any>);\n      this.flushQueue();\n    });\n  }\n\n  async getNetwork(): Promise<NetworkResponse> {\n    return this.sendCommand<NetworkResponse>('network');\n  }\n\n  async getTokens(): Promise<TokensResponse> {\n    return this.sendCommand<TokensResponse>('tokens');\n  }\n\n  // ===== Internals =====\n\n  private flushQueue() {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;\n    if (this.awaitingResponse) return;\n    const front = this.queue[0];\n    if (!front) return;\n    this.awaitingResponse = true;\n    this.ws.send(front.payload);\n  }\n\n  private startHeartbeat() {\n    const interval = this.opts.heartbeatIntervalMs;\n    if (!interval || interval <= 0) return;\n    this.stopHeartbeat();\n    this.heartbeatTimer = globalThis.setInterval(async () => {\n      // only when idle\n      if (this.awaitingResponse || this.queue.length > 0) return;\n      try {\n        const t0 = nowMs();\n        await this.sendCommand('network');\n        const rtt = Math.max(0, Math.round(nowMs() - t0));\n        this.ee.emit('heartbeat', { ok: true, rttMs: rtt });\n      } catch {\n        this.ee.emit('heartbeat', { ok: false });\n        this.maybeReconnectOnTimeout();\n      }\n    }, interval) as any;\n  }\n\n  private stopHeartbeat() {\n    if (this.heartbeatTimer != null) {\n      globalThis.clearInterval(this.heartbeatTimer as any);\n      this.heartbeatTimer = null;\n    }\n  }\n\n  private scheduleReconnect() {\n    this.setStatus('reconnecting');\n    const base = Math.min(\n      this.opts.reconnectMaxDelayMs ?? 12_000,\n      (this.opts.reconnectInitialDelayMs ?? 500) *\n        Math.pow(2, this.reconnectAttempt++),\n    );\n    const jitter = base * (this.opts.reconnectJitter ?? 0.2) * Math.random();\n    const delay = Math.floor(base + jitter);\n    this.ee.emit('reconnecting', {\n      attempt: this.reconnectAttempt,\n      delayMs: delay,\n    });\n    globalThis.setTimeout(() => this.connect().catch(() => {}), delay);\n  }\n\n  private maybeReconnectOnTimeout() {\n    if (\n      this.ws &&\n      this.ws.readyState === WebSocket.OPEN &&\n      this.opts.reconnect\n    ) {\n      this.log('warn', 'Timeout/heartbeat failure; reconnecting');\n      try {\n        this.ws.close(4001, 'timeout');\n      } catch {}\n      // onClose will schedule reconnect\n    }\n  }\n}\n"]}